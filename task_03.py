# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. 
# Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, 
# соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы 
# методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), 
# умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к 
# клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) 
# деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек 
# исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества 
# ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение 
# количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное 
# деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество 
# ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно 
# переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются 
# все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() 
# вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() 
# вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, cells) -> None:
        self.__cells = cells

    @property
    def cells(self):
        return self.__cells 

    def __add__(self, other):
        return Cell(self.cells + other.cells)

    def __sub__(self, other):
        if self.cells <= other.cells:
            raise NameError('Left cell must be larger than right!')
        return Cell(self.cells - other.cells)

    def __mul__(self, other):
        return Cell(self.cells * other.cells)

    def __truediv__(self, other):
        return Cell(self.cells // other.cells)

    @staticmethod
    def make_order(cell, cells_in_row):
        if cells_in_row < 1: return ''

        result_str = ''
        j = 0
        for i in range(cell.cells):
            result_str += '*'
            j += 1
            if j == cells_in_row:
                result_str += '\n'
                j = 0
        
        if j != 0:
            result_str += '\n'

        return result_str


my_cell_1 = Cell(43)
my_cell_2 = Cell(65)

print(Cell.make_order(my_cell_1 + my_cell_2, 7))
print(Cell.make_order(my_cell_2 - my_cell_1, 12))
print(Cell.make_order(my_cell_1 * my_cell_2, 15))
print(Cell.make_order(my_cell_2 / my_cell_1, 15))

print(Cell.make_order(my_cell_1 - my_cell_2, 12)) #Raised exeption